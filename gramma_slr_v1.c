/*

This file was generated by the "C - Kessels engine template.c" template.

*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>

#define NULL 0

#include "engine.h"                 /* The Kessels engine. */
#include "gramma_slr_v1.h"                /* Generated by GOLD. */



#define TRIMREDUCTIONS 1            /* 0=off, 1=on */
int Debug = 1;                      /* 0=off, 1=on */




/* Load input file from disk into memory. */
char *LoadInputFile(char *FileName) {
  FILE *Fin;
  char *InputBuf;
  struct stat statbuf;
  size_t BytesRead;

  /* Sanity check. */
  if ((FileName == NULL) || (*FileName == '\0')) return(NULL);

  /* Open the file. */
  Fin = fopen(FileName,"rb");
  if (Fin == NULL) {
    fprintf(stdout,"Could not open input file:     return(NULL);
    }

  /* Get the size of the file. */
  if (fstat(fileno(Fin),&statbuf) != 0) {
    fprintf(stdout,"Could not stat() the input file:     fclose(Fin);
    return(NULL);
    }

  /* Allocate memory for the input. */
  InputBuf = (char *)malloc(statbuf.st_size + 1);
  if (InputBuf == NULL) {
    fprintf(stdout,"Not enough memory to load the file:     fclose(Fin);
    return(NULL);
    }

  /* Load the file into memory. */
  BytesRead = fread(InputBuf,1,statbuf.st_size,Fin);
  InputBuf[statbuf.st_size] = '\0';

  /* Close the file. */
  fclose(Fin);

  /* Exit if there was an error while reading the file. */
  if (BytesRead != statbuf.st_size) {
    fprintf(stdout,"Error while reading input file:     free(InputBuf);
    return(NULL);
    }

  return(InputBuf);
  }




/* Make a readable copy of a string. All characters outside 32...128 are
   displayed as a HEX number in square brackets, for example "[0A]". */
void ReadableString(char *Input, char *Output, long int Width) {
  char s1[BUFSIZ];

  if (Output == NULL) return;
  while ((Input != NULL) && (*Input != '\0')) {
    if ((*Input >= 32) && ((unsigned char)*Input <= 127)) {
        if (Width > 1) *Output++ = *Input;
      } else {
        if (Width > 4) {
          sprintf(s1,"          *Output++ = '[';
          *Output++ = s1[0];
          *Output++ = s1[1];
          *Output++ = ']';
          }
        }
    Input++;
    }
  *Output = '\0';
  }




void ShowErrorMessage(struct ParseDataStruct *Data, char *Message) {
  struct TokenStruct *Token;
  char s1[BUFSIZ];

  Token = Data->TokenStack;
  if (Token != NULL) Token = Token->NextToken;
  if (Token == NULL) {
    fprintf(stdout,"    return;
    }
  if (Token->Data == NULL) {
    fprintf(stdout,"d column       Token->Column);
    return;
    }
  ReadableString(Token->Data,s1,BUFSIZ);
  fprintf(stdout,"d column s\n",Message,Token->Line,
    Token->Column,s1);
  }




void ShowIndent(int Indent) {
  int i;
  for (i = 0; i < Indent; i++) fprintf(stdout,"  ");
  }




/* Forward declaration of Interpret(); */
char *Interpret(struct TokenStruct *Token, int Debug, int Indent);




/* <ar> ::= '+' */
char *Rule_ar_Plus(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 1 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <ar> ::= '-' */
char *Rule_ar_Minus(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 1 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <ar> ::= OR */
char *Rule_ar_OR(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 1 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <ap> ::= '*' */
char *Rule_ap_Times(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 1 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <ap> ::= '/' */
char *Rule_ap_Div(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 1 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <ap> ::= '%' */
char *Rule_ap_Percent(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 1 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <ap> ::= AND */
char *Rule_ap_AND(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 1 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <e> ::= <e> <ar> <t> */
char *Rule_e(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 3 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <e> ::= <t> */
char *Rule_e2(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 1 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <t> ::= <t> <ap> <f> */
char *Rule_t(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 3 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <t> ::= <f> */
char *Rule_t2(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 1 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <f> ::= '(' <e> ')' */
char *Rule_f_LParen_RParen(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 3 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <f> ::= ID */
char *Rule_f_ID(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 1 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <f> ::= NUM */
char *Rule_f_NUM(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 1 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <opl> ::= <e> '!=' <e> */
char *Rule_opl_ExclamEq(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 3 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <opl> ::= <e> '==' <e> */
char *Rule_opl_EqEq(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 3 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <opl> ::= <e> '<' <e> */
char *Rule_opl_Lt(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 3 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <opl> ::= <e> '>' <e> */
char *Rule_opl_Gt(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 3 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <cond> ::= IF <opl> <stm> ELSE <stm> */
char *Rule_cond_IF_ELSE(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 5 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <attr> ::= ID '=' <e> */
char *Rule_attr_ID_Eq(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 3 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <attr> ::= ID '=' <opl> */
char *Rule_attr_ID_Eq2(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 3 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <loop> ::= LOOP '(' <opl> ')' <stm> */
char *Rule_loop_LOOP_LParen_RParen(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 5 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <loop> ::= LOOP <stm> '(' <opl> ')' */
char *Rule_loop_LOOP_LParen_RParen2(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 5 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <com> ::= <loop> */
char *Rule_com(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 1 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <com> ::= <cond> */
char *Rule_com2(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 1 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <com> ::= <attr> ';' */
char *Rule_com_Semi(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 2 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <com> ::= <function> */
char *Rule_com3(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 1 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <lib> ::= <function> <lib> */
char *Rule_lib(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 2 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <lib> ::= <function> */
char *Rule_lib2(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 1 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <lib> ::= '' */
char *Rule_lib_Apost(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 1 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <stm> ::= '{' <stm_> */
char *Rule_stm_LBrace(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 2 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <stm> ::= <com> */
char *Rule_stm(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 1 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <stm> ::= RETURN <opl> ';' */
char *Rule_stm_RETURN_Semi(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 3 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <stm> ::= RETURN <e> ';' */
char *Rule_stm_RETURN_Semi2(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 3 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <stm_> ::= <com> <stm_> */
char *Rule_stm_(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 2 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <stm_> ::= '}' */
char *Rule_stm__RBrace(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 1 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <stm_> ::= RETURN <opl> ';' '}' */
char *Rule_stm__RETURN_Semi_RBrace(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 4 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <stm_> ::= RETURN <e> ';' '}' */
char *Rule_stm__RETURN_Semi_RBrace2(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 4 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <function> ::= FUNCTION ID '(' <param> <stm> */
char *Rule_function_FUNCTION_ID_LParen(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 5 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <param> ::= ID ')' */
char *Rule_param_ID_RParen(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 2 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <param> ::= ')' */
char *Rule_param_RParen(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 1 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <param> ::= ID ',' <param> */
char *Rule_param_ID_Comma(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 3 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



char *(*RuleJumpTable[])(struct TokenStruct *Token, int Debug, int Indent) = {

  /* 0. <ar> ::= '+' */
  Rule_ar_Plus,

  /* 1. <ar> ::= '-' */
  Rule_ar_Minus,

  /* 2. <ar> ::= OR */
  Rule_ar_OR,

  /* 3. <ap> ::= '*' */
  Rule_ap_Times,

  /* 4. <ap> ::= '/' */
  Rule_ap_Div,

  /* 5. <ap> ::= '%' */
  Rule_ap_Percent,

  /* 6. <ap> ::= AND */
  Rule_ap_AND,

  /* 7. <e> ::= <e> <ar> <t> */
  Rule_e,

  /* 8. <e> ::= <t> */
  Rule_e2,

  /* 9. <t> ::= <t> <ap> <f> */
  Rule_t,

  /* 10. <t> ::= <f> */
  Rule_t2,

  /* 11. <f> ::= '(' <e> ')' */
  Rule_f_LParen_RParen,

  /* 12. <f> ::= ID */
  Rule_f_ID,

  /* 13. <f> ::= NUM */
  Rule_f_NUM,

  /* 14. <opl> ::= <e> '!=' <e> */
  Rule_opl_ExclamEq,

  /* 15. <opl> ::= <e> '==' <e> */
  Rule_opl_EqEq,

  /* 16. <opl> ::= <e> '<' <e> */
  Rule_opl_Lt,

  /* 17. <opl> ::= <e> '>' <e> */
  Rule_opl_Gt,

  /* 18. <cond> ::= IF <opl> <stm> ELSE <stm> */
  Rule_cond_IF_ELSE,

  /* 19. <attr> ::= ID '=' <e> */
  Rule_attr_ID_Eq,

  /* 20. <attr> ::= ID '=' <opl> */
  Rule_attr_ID_Eq2,

  /* 21. <loop> ::= LOOP '(' <opl> ')' <stm> */
  Rule_loop_LOOP_LParen_RParen,

  /* 22. <loop> ::= LOOP <stm> '(' <opl> ')' */
  Rule_loop_LOOP_LParen_RParen2,

  /* 23. <com> ::= <loop> */
  Rule_com,

  /* 24. <com> ::= <cond> */
  Rule_com2,

  /* 25. <com> ::= <attr> ';' */
  Rule_com_Semi,

  /* 26. <com> ::= <function> */
  Rule_com3,

  /* 27. <lib> ::= <function> <lib> */
  Rule_lib,

  /* 28. <lib> ::= <function> */
  Rule_lib2,

  /* 29. <lib> ::= '' */
  Rule_lib_Apost,

  /* 30. <stm> ::= '{' <stm_> */
  Rule_stm_LBrace,

  /* 31. <stm> ::= <com> */
  Rule_stm,

  /* 32. <stm> ::= RETURN <opl> ';' */
  Rule_stm_RETURN_Semi,

  /* 33. <stm> ::= RETURN <e> ';' */
  Rule_stm_RETURN_Semi2,

  /* 34. <stm_> ::= <com> <stm_> */
  Rule_stm_,

  /* 35. <stm_> ::= '}' */
  Rule_stm__RBrace,

  /* 36. <stm_> ::= RETURN <opl> ';' '}' */
  Rule_stm__RETURN_Semi_RBrace,

  /* 37. <stm_> ::= RETURN <e> ';' '}' */
  Rule_stm__RETURN_Semi_RBrace2,

  /* 38. <function> ::= FUNCTION ID '(' <param> <stm> */
  Rule_function_FUNCTION_ID_LParen,

  /* 39. <param> ::= ID ')' */
  Rule_param_ID_RParen,

  /* 40. <param> ::= ')' */
  Rule_param_RParen,

  /* 41. <param> ::= ID ',' <param> */
  Rule_param_ID_Comma 
  };




/* Walk through the parsed input script and interpret (execute, evaluate)
   all the statements. This is the heart of the beast and it's executed a
   great many times. You will want to keep it as light as possible.
   Input is a Token on the TokenStack, output is a string. The Token can
   be:
   - A symbol: return the Data of the Token.
   - A reduction (a Rule with all it's arguments): call the Rule's
     function and return it's result.
   */
char *Interpret(struct TokenStruct *Token, int Debug, int Indent) {
  /* Sanity check. */
  if (Token == NULL) return(NULL);

  /* If it's a symbol then return the value. */
  if (Token->Reduction == NULL) {
    if (Debug > 0) {
      ShowIndent(Indent);
      fprintf(stdout,"      }
    return(strdup(Token->Data));
    }

  /* Sanity check. */
  if (Token->Reduction->TokenStack == NULL) return(NULL);

  /* Call the rule and return the result. */
  if (Debug > 0) {
    ShowIndent(Indent);
    fprintf(stdout,"    }
  return(RuleJumpTable[Token->Reduction->Rule](Token,Debug,Indent + 1));
  }





int main(int argc, char *argv[]){
  char *InputBuf;
  struct ParseDataStruct *Data;
  struct TokenStruct *Token;
  short Result;

  /* Load the inputfile into memory. */
  InputBuf = LoadInputFile("Example.input");
  if (InputBuf == NULL) exit(1);

  /* Initialize the parser. */
  Data = ParserInitialize(InputBuf,strlen(InputBuf));

  /* Run the Parser. */
  Result = Parse(Data,TRIMREDUCTIONS,0);

  /* Show a message about the Parser result. */
  switch(Result) {
    case MESSAGEINTERNALERROR:
      fprintf(stdout,"Error: not enough memory to initialize the parser.\n");
      break;
    case MESSAGELEXICALERROR:
      ShowErrorMessage(Data,"Lexical error");
      break;
    case MESSAGECOMMENTERROR:
      ShowErrorMessage(Data,"Comment error");
      break;
    case MESSAGETOKENERROR:
      ShowErrorMessage(Data,"Tokenizer error");
      break;
    case MESSAGESYNTAXERROR:
      ShowErrorMessage(Data,"Syntax error");
      break;
    case MESSAGEACCEPT:
      /* Call the interpreter for all the tokens on the TokenStack. */
      for (Token = Data->TokenStack; Token != NULL; Token = Token->NextToken) {
        if (Debug > 0) fprintf(stdout,"\nStarting to interpret:\n");
        Interpret(Token,Debug,-1);
        }
      break;
    }

  /* Cleanup. */
  ParserCleanup(Data);
  free(InputBuf);
  }
