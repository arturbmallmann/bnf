/*

Example of how to run the Kessels engine and show the results.
Output is a list of all the tokens in the input.



Jeroen C. Kessels
Internet Engineer
http://www.kessels.com/

Copyright:   Jeroen C. Kessels
Date:        22 march 2006
Version:     1.8

*/




#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>                  /* wchar_t */
#include <sys/stat.h>

#include "engine.h"                 /* The Kessels engine. */
#include "grammar.h"                /* Generated by GOLD. */






/* Load input file from disk into memory. */
wchar_t *LoadInputFile(char *FileName) {
  FILE *Fin;
  char *Buf1;
  wchar_t *Buf2;
  struct stat statbuf;
  size_t BytesRead;
  unsigned long i;

  /* Sanity check. */
  if ((FileName == NULL) || (*FileName == '\0')) return(NULL);

  /* Open the file. */
  Fin = fopen(FileName,"rb");
  if (Fin == NULL) {
    fprintf(stdout,"Could not open input file: %s\n",FileName);
    return(NULL);
    }

  /* Get the size of the file. */
  if (fstat(fileno(Fin),&statbuf) != 0) {
    fprintf(stdout,"Could not stat() the input file: %s\n",FileName);
    fclose(Fin);
    return(NULL);
    }

  /* Allocate memory for the input. */
  Buf1 = (char *)malloc(statbuf.st_size + 1);
  Buf2 = (wchar_t *)malloc(sizeof(wchar_t) * (statbuf.st_size + 1));
  if ((Buf1 == NULL) || (Buf2 == NULL)) {
    fprintf(stdout,"Not enough memory to load the file: %s\n",FileName);
    fclose(Fin);
    if (Buf1 != NULL) free(Buf1);
    if (Buf2 != NULL) free(Buf2);
    return(NULL);
    }

  /* Load the file into memory. */
  BytesRead = fread(Buf1,1,statbuf.st_size,Fin);
  Buf1[BytesRead] = '\0';

  /* Close the file. */
  fclose(Fin);

  /* Exit if there was an error while reading the file. */
  if (BytesRead != statbuf.st_size) {
    fprintf(stdout,"Error while reading input file: %s\n",FileName);
    free(Buf1);
    free(Buf2);
    return(NULL);
    }

  /* Convert from ASCII to Unicode. */
  for (i = 0; i <= BytesRead; i++) Buf2[i] = Buf1[i];
  free(Buf1);

  return(Buf2);
  }




/* Make a readable copy of a string. All characters outside 32...128 are
   displayed as a HEX number in square brackets, for example "[0A]". */
void ReadableString(wchar_t *Input, wchar_t *Output, long Width) {
  char s1[BUFSIZ];
  long i1;
  long i2;

  /* Sanitu check. */
  if ((Output == NULL) || (Width < 1)) return;
  Output[0] = 0;
  if (Input == NULL) return;

  i1 = 0;
  i2 = 0;
  while (Input[i1] != 0) {
    if ((Input[i1] >= 32) && (Input[i1] <= 127)) {
        if (Width > 1) Output[i2++] = Input[i1];
      } else {
        if (Width > 4) {
          sprintf(s1,"%02X",*Input);
          Output[i2++] = '[';
          Output[i2++] = s1[0];
          Output[i2++] = s1[1];
          Output[i2++] = ']';
          }
        }
    i1++;
    }
  Output[i2] = 0;
  }




/* Example of how to run the tokenizer. The parser calls the tokenizer
   internally, you don't have to do it yourself. This is just an example
   that makes visible what the tokenizer does. */
int main(int argc, char *argv[]){
  wchar_t *InputBuf;                    /* The input data. */
  long InputSize;                     /* Size of the input data. */
  long InputHere;                     /* Index into input data. */
  long Line;                          /* Current line number. */
  long Column;                        /* Current column number. */
  wchar_t *Value;
  int Symbol;
  wchar_t s1[BUFSIZ];

  /* Initialize. */
  InputHere = 0;
  Line = 1;
  Column = 1;

  /* Load the inputfile into memory. */
  InputBuf = LoadInputFile("Example.input");
  if (InputBuf == NULL) exit(1);
  InputSize = wcslen(InputBuf);

  /* Call the tokenizer until all data has been parsed. Show all the tokens
     that were parsed, one line per token. */
  while (1) {
    Value = RetrieveToken(InputBuf,InputSize,&InputHere,&Line,&Column,&Symbol);
    ReadableString(Value,s1,BUFSIZ);
    if (Grammar.SymbolArray[Symbol].Kind == SYMBOLEOF) {
      fprintf(stdout,  "SYMBOLEOF          %-20S\n",Grammar.SymbolArray[Symbol].Name);
      break;
      }
    switch(Grammar.SymbolArray[Symbol].Kind) {
      case SYMBOLNONTERMINAL:
        fprintf(stdout,"SYMBOLNONTERMINAL  %-20S '%S'\n",Grammar.SymbolArray[Symbol].Name,s1);
        break;
      case SYMBOLTERMINAL:
        fprintf(stdout,"SYMBOLTERMINAL     %-20S '%S'\n",Grammar.SymbolArray[Symbol].Name,s1);
        break;
      case SYMBOLWHITESPACE:
        fprintf(stdout,"SYMBOLWHITESPACE   %-20S '%S'\n",Grammar.SymbolArray[Symbol].Name,s1);
        break;
      case SYMBOLCOMMENTSTART:
        fprintf(stdout,"SYMBOLCOMMENTSTART %-20S '%S'\n",Grammar.SymbolArray[Symbol].Name,s1);
        break;
      case SYMBOLCOMMENTEND:
        fprintf(stdout,"SYMBOLCOMMENTEND   %-20S '%S'\n",Grammar.SymbolArray[Symbol].Name,s1);
        break;
      case SYMBOLCOMMENTLINE:
        fprintf(stdout,"SYMBOLCOMMENTLINE  %-20S '%S'\n",Grammar.SymbolArray[Symbol].Name,s1);
        break;
      case SYMBOLERROR:
        fprintf(stdout,"SYMBOLERROR        %-20S '%S'\n",Grammar.SymbolArray[Symbol].Name,s1);
        break;
      }
    free(Value);
    }

  /* Cleanup. */
  free(InputBuf);
  }
